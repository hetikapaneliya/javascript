<script>
  //ex of array
  let arr = [1, 2, 3, 4];
  let arr2 = [5, 6];

  arr = [...arr, ...arr2];
  console.log(arr);
  //output:
  //1,2,3,4,5,6

  //using array method

  let ab = ["A, B, C, D"];
  let cd = [...ab];

  cd.push("E");
  console.log(cd);
  //output:
  //A,B,C,D,E

  //array

  const ac = [11, 12, 13, 14];
  const ef = [15, ...ac, 16];
  console.log(ef);

  //min and max value

  const xy = [45, 67, 89, 12];

  console.log(Math.min(...xy));
  console.log(Math.max(...xy));

  //using in obeject

  const family = {
    name: "Hetika",
    lastname: "Paneliya",
    age: 23,
    city: "Surat",
  };

  const spreadop = { ...family };
  console.log(spreadop);

  //one or more object using spread operator

  const car1 = {
    car: "Swift",
    brand: "tata",
    price: 1.5,
  };
  const car2 = {
    car: "audi",
    brand: "Honda",
  };
  const carbrand = { ...car1, ...car2 };
  console.log(carbrand);

  //function using sperad oprator
  function sum(x, y, z) {
    console.log(x + y + z);
  }
  const nnum = [1, 2, 3];
  console.log(sum(...nnum));

  //sperad operator using object

  /* const obj1 = {
                           objname: "dev",
                           objjender: "male",
                         };

                         const obj2 = {
                           ...obj1,
                           objage: 19,
                         };

                         obj2["height"] = 5.4;
                         console.log(obj2);
                       */
  //

  let furits = ["mango", "orange", "apple"];
  let fruitcopy = [...furits];

  console.log(fruitcopy);

  //nodelist using sprad operator

  let nodelist = document.querySelectorAll(".class");
  var nodearray = [...nodelist];

  //converting string to character

  let name = "Ram";
  let char = [...name];
  console.log(char);

  //passing argument with arrow function

  const dynamic = (args1, ...args) => {
    console.log("args1: " + args1);
    console.log("args: " + args);
  };
  dynamic(1, 2, 3, 4, 5, 6);

  //Spreading elements together with an individual element

  const fruit = ["mango", "orange", "kiwi"];
  const newfruit = ["swtobarry", ...fruit];
  console.log(newfruit);

  //concat array

  const arra = ["a", "b", "c", "d"];
  const arra2 = ["e", "f", "g"];

  const arra1 = arra.concat(arra2);
  console.log(arra1);

  //rest parameter

  args = "Ram";
  char = [...args];
  console.log(char);

  function linuxhint(a, ...aq) {
    console.log("First perameter:" + a);
    console.log("second peramater:" + aq);
  }
  linuxhint(1, 2, 3, 4, 5);

  function rest(first, second, ...remainder) {
    console.log(remainder);
  }
  rest(11, 12, 13, 14, 15);

  //rest perameter using function

  function myfun(a, b, ...manyargs) {
    console.log(a);
    console.log(b);
    console.log("manyargs", manyargs);
  }
  myfun("one", "two", "three", "four", "five");

  //short circulting that is the useing in boolean variable.
  //that is return in true or false value.

  console.log("=======AND======");

  console.log("true" && "false"); //false
  console.log(6 && 7); //7
  console.log(3 && "hetika"); //hetika
  console.log("hetika" && "dev"); //dev

  console.log("======OR====");

  console.log(null || 0 || "" || "hello" || 23 || undefined); //hello
  console.log("true" || "false"); //true
  console.log(3 || "hetika"); //3
  console.log(4 || 5); //4
  console.log("hetika" || "dev"); //hetika

  var name1 = "abc";
  if (name1 == "hetika" || name1 == "abc") {
    console.log(name1);
  }

  //nullish coelsing

  let result = undefined ?? "hello";
  console.log(result);

  result = null ?? 12;
  console.log(result);

  result = "abcd" ?? null;
  console.log(result);

  result = 145 ?? 12;
  console.log(result);

  result = null ?? undefined;
  console.log(result);

  result = "abcd" ?? "efghi";
  console.log(result);

  result = null ?? "";
  console.log(result);

  result = "fg" ?? 12;
  console.log(result);

  result = 4 < 5 ?? true;
  console.log(result);

  result = 12 > 11118 ?? false;
  console.log(result);

  result = ["a", "b", "v"] ?? 12;
  console.log(result);

  //for-of loop

  //for-of loop using string
  const string = "code";
  for (let i of string) {
    console.log(i);
  }

  //for-of loop using array.
  const students = ["john", "sara", "shark"];
  for (ele of students) {
    console.log(ele);
  }

  //for-of loop usingobjects
  //for-in and for-of loop compearison
  /*                     for..in                        for..of
                        Applies to         Enumerable Properties          Iterable Collections
                        Objects            Yes                            No
                        Arrays             Yes, but not advised           Yes
                        Strings            Yes, but not advised           Yes*/

  const obj = {
    first: 154,
    second: 163,
    thired: 255,
  };

  for (let keys in obj) {
    console.log(obj[keys]);
  }

  console.log("====for-of loop===");
  const marks = [154, 555, 23698, 589, 258];
  for (let i of marks) {
    console.log(i);
  }
  // Print names and values of object properties
  const shark = {
    species: "great white",
    color: "white",
    numberOfTeeth: Infinity,
  };

  for (attribute in shark) {
    console.log(`${attribute}`.toUpperCase() + `: ${shark[attribute]}`);
  }

  //enhanced objects litterls::that means global scope code to put the javascript code using objects.

  let firstname = "hetika",
    lastname = "paneliya",
    age = "23";

  let customer = {
    firstname,
    lastname,
    age,
  };
  console.log(customer);

  //enhanced objects litterial using function

  let carname = "creta",
    color = "white",
    capacity = 7;

  let cardetails = function () {
    console.log(
      `This is car name is ${carname} and this car color is ${color} and that car capicity is ${capacity}...`
    );
  };

  let details = {
    carname,
    color,
    capacity,
    cardetails,
  };
  details.cardetails();

  //optinal chinning::means to access in objects property in javascript code.
  //synax: objname.objvalue?.objproperty
  //       obj.val?.prop

  const adventurer = {
    name: "Alice",
    cat: {
      name: "Dinah",
    },
  };

  const catname = adventurer.cat?.name;
  console.log(catname);

  //looping objects keys,values,entries..

  const person = {
    personname: "abcd",
    personage: 20,
    personstatus: "active",
  };

  console.log(person);
  console.log(Object.keys(person));
  console.log(Object.values(person));
  console.log(Object.entries(person));

  ///

  const objkeys = Object.keys(person);
  console.log(objkeys);

  objkeys.forEach((key) => console.log(key));
  console.log("======keys=====");
  console.log(objkeys[2]);

  const emptyobj = {};
  console.log(Object.keys(emptyobj));

  //objects values

  console.log("=====values====");

  const objvalues = Object.values(person);
  console.log(objvalues);

  objvalues.forEach((values) => console.log(values));

  console.log(objvalues[2]);

  const emptyobj1 = {};
  console.log(Object.values(emptyobj1));

  //entries

  console.log("=====entries====");

  const objentries = Object.entries(person);
  console.log(objentries);

  objentries.forEach((entries) => console.log(entries));

  console.log(objentries[2]);

  const emptyobj2 = {};
  console.log(Object.values(emptyobj2));

  //objects keys values and entries using for-of loop

  const wonam = {
    wname: "john",
    wcolor: "white",
    wgender: "female",
  };

  const myobjenteris = Object.entries(wonam);
  console.log(myobjenteris);
  //for-of loop

  for (const entry of myobjenteris) {
    const [key, value] = entry;

    console.log(`key:${key} value: ${value} entry:{${key}: ${value}}`);
  }

  //ojects keys values and entries using destruvturing onjects..

  console.log("---=====----");

  for (const [key, value] of myobjenteris) {
    console.log(`key:${key} value: ${value} entry:{${key}: ${value}}`);
  }

  //sets stores uniqe values .not store in duplicates values.
  //sets using adifferent method :set,clear,delete,has,foreach,key,values,entries

  var set1 = new Set();

  set1.add(10);
  set1.add(20);
  set1.add(10);
  set1.add(30);
  set1.add(40);
  set1.delete(40);
  console.log(set1.has(202));
  console.log(set1.size);

  //sets using foreach loop

  set1.forEach((item) => {
    console.log("thi is item:", item);
  });

  //sets using for-of loop

  console.log("===========");
  for (let item of set1) {
    console.log("This Is item :", item);
  }
  //clear

  //set1.clear();
  console.log(set1);

  //Map:: means we can use any type of keys or values.

  const map1 = new Map();
  console.log(map1);

  const KEY1 = "MYSTR",
    key2 = {},
    key3 = function () {};

  //set the keys

  map1.set(KEY1, "This is a string");
  map1.set(key2, "This is a empty objects");
  map1.set(key3, "This is a empty function");

  console.log(map1);
  //get keyvalues

  const value1 = map1.get(KEY1);
  console.log(value1);

  const value2 = map1.get(key2);
  console.log(value2);

  const value3 = map1.get(key3);
  console.log(value3);

  //defines a size of map
  console.log(map1.size);

  for (let [keys, value] of map1) {
    console.log(keys, value);
  }

  //get only keys using for of loop
  for (let key of map1.keys()) {
    console.log("keys is:", key);
  }

  //get only values using for -of loop
  for (let value of map1.values()) {
    console.log("values is:", value);
  }

  //converting map to array

  const myarray = Array.from(map1);
  console.log("Map to array", myarray);

  //converting map array to keys
  //converting map array to values same it is
  const mykeyarray = Array.from(map1.keys());
  console.log("Map to  key array", mykeyarray);
  ////
  /*
               Let's say a triple (a, b, c) is a zigzag if either a < b > c or a > b < c.
               Given an array of integers numbers, your task is to check all the triples of its consecutive elements for being a zigzag. More formally, your task is to construct an array of length
               numbers.length - 2, where the ith element of the output array equals 1 if the triple (numbers[i], numbers[i + 1], numbers[i + 2]) is a zigzag, and 0 otherwise.
               Example
               For numbers = [1, 2, 1, 3, 4], the output should be isZigzag(numbers) = [1, 1, 0].
               (numbers[0], numbers[1], numbers[2]) = (1, 2, 1) is a zigzag, because 1 < 2 > 1;
               (numbers[1], numbers[2] , numbers[3]) = (2, 1, 3) is a zigzag, because 2 > 1 < 3;
               (numbers[2], numbers[3] , numbers[4]) = (1, 3, 4) is not a zigzag, because 1 < 3 < 4;
               For numbers = [1, 2, 3, 4], the output should be isZigzag(numbers) = [0, 0];
               Since all the elements of numbers are increasing, there are no zigzags.
               For numbers = [1000000000, 1000000000, 1000000000], the output should be isZigzag(numbers) = [0].
               Since all the elements of numbers are the same, there are no zigzags.
               Input/Output
               [execution time limit] 4 seconds (js)
               [input] array.integer numbers
               An array of integers.
               Guaranteed constraints:
               3 ≤ numbers.length ≤ 100,
               1 ≤ numbers[i] ≤ 109.
               [output] array.integer
               Return an array, where the ith element equals 1 if the triple (numbers[i], numbers[i + 1], numbers[i + 2]) is a zigzag, and 0 otherwise.
                */

  const numbers = [10000000, 10000000, 10000000];
  const value = [];
  var flag = true;

  for (let i = 0; i < numbers.length - 1; i++) {
    if (!numbers[i] || !numbers[i + 1] || !numbers[i + 2]) break;
    value.push(
      (numbers[i] < numbers[i + 1] && numbers[i + 1] > numbers[i + 2]) ||
        (numbers[i] > numbers[i + 1] && numbers[i + 1] < numbers[i + 2])
        ? 1
        : 0
    );
    console.log(value);
  }

  //
  const s1 = "super";
  const s2 = "tower";
  let mearge = s1.concat(s2);
  console.log(`Mearge string(s1,s2): ${mearge}`);
  /*let s1 = "super";
             let s2 = "tower";
             let mearge = s1.concat(s2);
             console.log(`Mearge string(s1,s2): ${mearge}`);*/

  /*


        You are given an array of integers arr and an array of queries queries, where each query represents a triple of integers. Your task is to find the number of occurrences of each query
         as a subsequence in the given array arr.
        In other words, for each query triple (x, y, z) your task is to find number of triples (i, j, k), such that 0 ≤ i < j < k < arr.length and also arr[i] = x, arr[j] = y, and arr[k] = z.
        Example
        For arr = [1, 2, 3, 4, 5] and queries = [[1, 2, 4], [2, 4, 3], [1, 1, 1]], the output should be findTheTriples(arr, queries) = [1, 0, 0].

        The first query [1, 2, 4] occurs in arr as a subsequence only once: (i, j, k) = (0, 1, 3) (arr[0] = 1, arr[1] = 2, arr[3] = 4). So, the answer is 1 for the first query.

        The second query [2, 4, 3] doesn't occur in arr as a subsequence: all elements of the query exist in arr, but in a different order.

        The third query [1, 1, 1] doesn't occur in arr as a subsequence, because arr doesn't contain three 1s.

        So the answer is [1, 0, 0].

        For arr = [1, 2, 2, 1, 2, 1, 2] and queries = [[1, 1, 2], [1, 2, 1]], the output should be findTheTriples(arr, queries) = [4, 6].
        The first query [1, 1, 2] occurs in arr as a subsequence four times:
        (i, j, k) = (0, 3, 4): a[0] = 1, a[3] = 1, a[4] = 2;
        (i, j, k) = (0, 3, 6): a[0] = 1, a[3] = 1, a[6] = 2;
        (i, j, k) = (0, 5, 6): a[0] = 1, a[5] = 1, a[6] = 2;
        (i, j, k) = (3, 5, 6): a[3] = 1, a[5] = 1, a[6] = 2.
        The second query [1, 2, 1] occurs in arr six times:
        (i, j, k) = (0, 1, 3): a[0] = 1, a[1] = 2, a[3] = 1;
        (i, j, k) = (0, 1, 5): a[0] = 1, a[1] = 2, a[5] = 1;
        (i, j, k) = (0, 2, 3): a[0] = 1, a[2] = 2, a[3] = 1;
        (i, j, k) = (0, 2, 5): a[0] = 1, a[2] = 2, a[5] = 1;
        (i, j, k) = (0, 4, 5): a[0] = 1, a[4] = 2, a[5] = 1;
        (i, j, k) = (3, 4, 5): a[3] = 1, a[4] = 2, a[5] = 1.
        So the answer is [4, 6].
        For arr = [1, 1, 1, 1] and queries = [[1, 1, 1]], the output should be findTheTriples(arr, queries) = [4].
        The only query [1, 1, 1] occurs in arr four times:
        (i, j, k) = (0, 1, 2): a[0] = 1, a[1] = 1, a[2] = 1;
        (i, j, k) = (0, 1, 3): a[0] = 1, a[1] = 1, a[3] = 1;
        (i, j, k) = (0, 2, 3): a[0] = 1, a[2] = 1, a[3] = 1;
        (i, j, k) = (1, 2, 3): a[1] = 1, a[2] = 1, a[3] = 1;
        So the answer is [4].
        */

  /* function count(data, queries, x, y, z) {
      //
      const result = [];
      for (let i = 0; i < data.length; i++) {
        if (data[x] < data[y] < data[z]);
        else {
          //
          data.length;
        }
      }
    }
  */
  function subsequence(data, queries, i, j) {
    let count = 0;
    let total_count = [];
    for (i = 0; i < data.length; i++) {
      if (queries[i] == data[j]) {
        i++;
      } else {
        j++;
      }
      if (i == queries) {
        count++;
      }
    }
  }
  const data = [1, 2, 3, 4, 5];
  const queries = [
    [1, 2, 4],
    [2, 4, 3],
    [1, 1, 1],
  ];

  console.log(subsequence(data, queries));
</script>
